# ボリューム操作動作検証計画

## バージョン: v4.43.0
## 作成日: 2025-10-28
## 検証対象: ストレージ切り替え機能

---

## 📋 検証パターン一覧

### **パターン1: 通常の内蔵→外部転送**
**前提条件:**
- 内蔵ストレージに完全なデータ（100MB以上）が存在
- 外部ボリュームは存在するが未マウント、またはマウント済みで空

**期待される動作:**
1. ✅ データサイズ計算が正確（内蔵データ）
2. ✅ 容量チェックが正確（外部ボリューム）
3. ✅ rsync --delete で差分同期実行
4. ✅ 内蔵データが完全削除
5. ✅ 外部ボリュームが内蔵パスにマウント
6. ✅ 内蔵ストレージフラグが削除
7. ✅ ゲームが正常起動

**検証コマンド:**
```bash
# 事前確認
ls -lah ~/Library/Containers/com.example.app/
du -sh ~/Library/Containers/com.example.app/

# 転送後確認
mount | grep PlayCover
ls -lah ~/Library/Containers/com.example.app/
du -sh ~/Library/Containers/com.example.app/
```

---

### **パターン2: 通常の外部→内蔵転送**
**前提条件:**
- 外部ボリュームに完全なデータ（100MB以上）が存在
- 内蔵パスは外部ボリュームがマウントされている状態

**期待される動作:**
1. ✅ データサイズ計算が正確（外部データ）
2. ✅ 容量チェックが正確（内蔵ストレージ）
3. ✅ rsync（--delete なし）で完全コピー
4. ✅ 外部ボリュームがアンマウント（削除しない）
5. ✅ 外部データが保持される
6. ✅ 内蔵ストレージフラグが作成
7. ✅ ゲームが正常起動

**検証コマンド:**
```bash
# 事前確認
mount | grep PlayCover
diskutil list | grep -A 5 "Container disk"

# 転送後確認
mount | grep PlayCover  # 外部がアンマウントされているか
diskutil list | grep "app_volume_name"  # ボリューム自体は存在するか
ls -lah ~/Library/Containers/com.example.app/
```

---

### **パターン3: 内蔵が空（0バイト）→外部転送**
**前提条件:**
- 内蔵パスが存在するが完全に空（0バイト）
- 外部ボリュームは存在する

**期待される動作:**
1. ✅ 「コピー元が空です（0バイト）」警告表示
2. ✅ rsync がスキップされる
3. ✅ 空の内蔵ディレクトリが削除
4. ✅ 外部ボリュームが直接マウント
5. ✅ 内蔵ストレージフラグが削除
6. ✅ エラーなく完了

**検証コマンド:**
```bash
# 事前に空のディレクトリ作成
sudo mkdir -p ~/Library/Containers/com.example.app/Data
sudo chown -R $(id -u):$(id -g) ~/Library/Containers/com.example.app/
du -sh ~/Library/Containers/com.example.app/  # 0バイト確認

# 転送後確認
mount | grep com.example.app
ls -lah ~/Library/Containers/com.example.app/
```

---

### **パターン4: 外部が空（0バイト）→内蔵転送**
**前提条件:**
- 外部ボリュームが存在しマウント済みだが完全に空（0バイト）
- 内蔵パスは外部ボリュームがマウントされている

**期待される動作:**
1. ✅ 「外部ボリュームが空です（0バイト）」警告表示
2. ✅ rsync がスキップされる
3. ✅ 空の内蔵ディレクトリが作成（適切な権限）
4. ✅ 外部ボリュームがアンマウント（削除しない）
5. ✅ 内蔵ストレージフラグが作成
6. ✅ エラーなく完了

**検証コマンド:**
```bash
# 事前確認（外部が空）
mount | grep com.example.app
du -sh ~/Library/Containers/com.example.app/  # マウント先のサイズ

# 転送後確認
mount | grep com.example.app  # アンマウント確認
ls -ld ~/Library/Containers/com.example.app/  # 権限確認
du -sh ~/Library/Containers/com.example.app/  # 0バイト確認
```

---

### **パターン5: 差分同期の動作確認（内蔵→外部）**
**前提条件:**
- 内蔵と外部の両方にデータが存在
- 内蔵側に新しいファイルが追加されている
- 外部側に古いファイルが残っている

**期待される動作:**
1. ✅ rsync --delete が古いファイルを削除
2. ✅ 新しいファイルが追加される
3. ✅ 差分のみが転送される（全体転送ではない）
4. ✅ 最終的に内蔵と外部が完全に一致
5. ✅ 内蔵データが削除される

**検証準備:**
```bash
# 内蔵側に新ファイル作成
echo "new data" > ~/Library/Containers/com.example.app/Data/new_file.txt

# 外部側の状態確認（マウント前にボリュームを一時マウント）
# ここで古いファイルが残っているか確認
```

**検証コマンド:**
```bash
# 転送前に両方の内容をリスト化
find ~/Library/Containers/com.example.app/ -type f > before_internal.txt

# 転送後に外部ボリュームの内容確認
# 一時的にマウントして確認
find /path/to/temp/mount/ -type f > after_external.txt

# 差分確認
diff before_internal.txt after_external.txt
```

---

### **パターン6: 容量不足エラーハンドリング**
**前提条件:**
- 内蔵データが100GB
- 外部ボリュームの空き容量が50GB

**期待される動作:**
1. ✅ 容量チェックでエラー検出
2. ✅ 「容量が不足しています」エラー表示
3. ✅ 転送が中断される
4. ✅ データが破損しない
5. ✅ 元の状態が保持される

**検証方法:**
```bash
# 外部ボリュームの空き容量確認
df -h | grep PlayCover

# 大きなテストファイル作成（容量不足をシミュレート）
# 実際には容量不足の状態を作るのは困難なので、
# コードレビューでロジックを確認
```

---

### **パターン7: 転送中断からの復旧**
**前提条件:**
- 内蔵→外部転送中にCtrl+Cで中断

**期待される動作:**
1. ✅ rsync が安全に停止
2. ✅ 部分的にコピーされたデータが残る
3. ✅ 内蔵データは削除されていない（rsync完了前のため）
4. ✅ 再実行で再開可能

**検証方法:**
```bash
# 転送開始後、数秒でCtrl+C
# その後の状態確認
ls -lah ~/Library/Containers/com.example.app/
mount | grep com.example.app
```

---

### **パターン8: 同時実行の排他制御**
**前提条件:**
- 2つのターミナルで同じスクリプトを起動
- 両方で同時にストレージ切り替えを実行

**期待される動作:**
1. ✅ ロックファイルによる排他制御
2. ✅ 2つ目の実行がブロックされる
3. ✅ 適切なエラーメッセージ表示
4. ✅ データ破損が発生しない

**検証方法:**
```bash
# ターミナル1
./0_PlayCover-ManagementTool.command
# メニュー3を選択

# ターミナル2（同時に）
./0_PlayCover-ManagementTool.command
# メニュー3を選択

# ロックファイル確認
ls -lah /tmp/.playcover-mapping-*.lock
```

---

### **パターン9: ボリューム未マウント状態からの転送**
**前提条件:**
- 外部ボリュームが存在するが未マウント
- 内蔵→外部転送を実行

**期待される動作:**
1. ✅ 外部ボリュームを自動マウント（一時マウントポイント）
2. ✅ データ転送実行
3. ✅ 一時マウント解除
4. ✅ 最終的に正しいパスにマウント

**検証コマンド:**
```bash
# 事前にアンマウント
sudo umount ~/Library/Containers/com.example.app/ 2>/dev/null

# ボリューム存在確認
diskutil list | grep app_volume_name

# 転送実行後の確認
mount | grep com.example.app
```

---

### **パターン10: マッピングファイルの整合性**
**前提条件:**
- ストレージ切り替え前後でマッピングファイルが存在

**期待される動作:**
1. ✅ 内蔵→外部後もマッピングエントリが保持される
2. ✅ 外部→内蔵後もマッピングエントリが保持される
3. ✅ ボリューム名とBundle IDの関連付けが正しい
4. ✅ 重複エントリが作成されない

**検証コマンド:**
```bash
# マッピングファイルの確認
cat .playcover-volume-mapping.tsv

# 切り替え前後で比較
diff before_mapping.tsv after_mapping.tsv

# 重複チェック
sort .playcover-volume-mapping.tsv | uniq -d
```

---

## 🔧 検証環境準備

### 必要なもの
1. テスト用アプリ（小さいゲームアプリ推奨）
2. 外部SSD（最低50GB空き容量）
3. 各パターン用のテストデータ

### テストアプリの準備
```bash
# PlayCoverで小さいアプリをインストール
# 例: Among Us, Subway Surfers など

# テストデータ作成
cd ~/Library/Containers/com.example.app/Data/
mkdir -p Documents/test
for i in {1..10}; do
    dd if=/dev/random of=Documents/test/file_${i}.dat bs=1m count=10
done
```

---

## 📊 検証結果記録シート

| パターン | 実行日時 | 結果 | 備考 |
|---------|---------|------|------|
| 1. 通常の内蔵→外部 | | ⬜ | |
| 2. 通常の外部→内蔵 | | ⬜ | |
| 3. 内蔵空→外部 | | ⬜ | |
| 4. 外部空→内蔵 | | ⬜ | |
| 5. 差分同期 | | ⬜ | |
| 6. 容量不足 | | ⬜ | |
| 7. 転送中断 | | ⬜ | |
| 8. 同時実行 | | ⬜ | |
| 9. 未マウント転送 | | ⬜ | |
| 10. マッピング整合性 | | ⬜ | |

**凡例:**
- ✅ 成功
- ❌ 失敗
- ⚠️ 部分的に成功
- ⬜ 未実施

---

## 🐛 既知の問題と注意事項

### 検証時の注意点
1. **バックアップ必須**: 重要なゲームデータで検証しない
2. **時間確保**: 各パターンで10-30分かかる可能性
3. **ログ保存**: エラーが発生した場合はターミナル出力を保存
4. **段階的検証**: 簡単なパターンから順に実施

### トラブルシューティング
```bash
# ロックファイルが残った場合
rm -f /tmp/.playcover-mapping-*.lock

# ボリュームが応答しない場合
sudo diskutil unmountDisk force /dev/diskXsY

# 権限エラーの場合
sudo chown -R $(id -u):$(id -g) ~/Library/Containers/com.example.app/
```

---

## 📝 検証チェックリスト

### 事前準備
- [ ] テストアプリをインストール
- [ ] 外部SSDを接続
- [ ] PlayCover統合管理ツール v4.43.0を配置
- [ ] バックアップを作成

### パターン1-5（基本動作）
- [ ] パターン1: 通常の内蔵→外部転送
- [ ] パターン2: 通常の外部→内蔵転送
- [ ] パターン3: 内蔵が空→外部転送
- [ ] パターン4: 外部が空→内蔵転送
- [ ] パターン5: 差分同期の動作確認

### パターン6-10（エッジケース）
- [ ] パターン6: 容量不足エラー
- [ ] パターン7: 転送中断からの復旧
- [ ] パターン8: 同時実行の排他制御
- [ ] パターン9: ボリューム未マウント転送
- [ ] パターン10: マッピングファイル整合性

### 事後確認
- [ ] 全てのボリュームを正しくアンマウント
- [ ] 一時ファイル/ロックファイルのクリーンアップ
- [ ] ゲームが正常起動することを確認
- [ ] 検証結果をドキュメント化

---

## 🎯 自動検証スクリプト（今後の拡張）

将来的には以下のような自動検証スクリプトを作成可能：

```bash
#!/bin/zsh
# volume_operations_auto_test.sh

test_pattern_1() {
    # 通常の内蔵→外部転送を自動検証
}

test_pattern_2() {
    # 通常の外部→内蔵転送を自動検証
}

# ... 他のパターン

run_all_tests() {
    echo "自動検証を開始します..."
    test_pattern_1
    test_pattern_2
    # ...
    echo "全ての検証が完了しました"
}
```

---

## 📞 サポート

問題が発生した場合：
1. エラーメッセージの全文を記録
2. 実行したコマンドを記録
3. システム情報を収集（macOS バージョン、空き容量など）
4. ログファイルを確認

---

**検証担当者:** ___________________
**検証完了日:** ___________________
**署名:** ___________________
